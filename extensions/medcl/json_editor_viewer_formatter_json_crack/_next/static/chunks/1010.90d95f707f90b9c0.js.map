{"version":3,"file":"static/chunks/1010.90d95f707f90b9c0.js","mappings":"+FAmaEA,EAAOC,OAAO,CA1ZhB,SAAkBC,CAAI,CAAEC,CAAQ,MAE1BC,EAF4BC,EAAAA,CAAAA,CAAAA,UAAAA,MAAAA,CAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,EAAAA,SAAAA,CAAAA,EAAAA,CAAgBC,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,EAAAA,SAAAA,CAAAA,EAAAA,CAAiBC,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,EAAAA,SAAAA,CAAAA,EAAAA,CAG7DC,EAAK,GACLC,EAAO,EAELC,EAAO,CAAC,EACRC,EAAQ,EAAE,CACZC,EAAc,GAEdC,EAAS,GAEb,GAAI,CAEFT,EADOU,KAAKC,KAAK,CAACb,EAAKc,OAAO,CAAC,wBAAyB,QAE1D,CAAE,MAAOC,EAAG,CACV,MAAO,CACLT,GAAI,GACJU,MAAOD,EAAEE,OAAO,CAEpB,CAOA,OALAhB,EAAWiB,EAAOjB,GAAY,QAgL5BK,GA/KK,QAAiBa,MAAA,CAATlB,EAAS,KAExBmB,EAAWlB,GAEJ,CACLI,GAAIH,EAAWG,GAAMI,EAAeJ,CACtC,EAEA,SAASc,EAAWlB,CAAK,MAiQiBmB,EA3F1BC,MAtKWC,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAQ,EACjC,GAAI,iBAAOrB,GAAsBA,OAAAA,GAC/B,GAAIsB,MAAMC,OAAO,CAACvB,GAAQ,KACpBwB,EACJ,IAAMC,EAAczB,EAAM0B,MAAM,CAEhC,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAaE,IAAK,CACpC,IAAMC,EAAWC,EAAO7B,CAAK,CAAC2B,EAAE,EAChC,GAAKH,EACA,IAAIA,GAAaI,GAEhBJ,QAsP4BL,EAvPiBK,EAAjDA,EAwPR,SAAIM,EAAKC,MAAM,CAAC,EAAG,IAAiBZ,OAAAA,EAAKY,MAAM,CAAC,EAAG,GAxPJH,EAyPtCE,OAAAA,EAAKC,MAAM,CAAC,EAAG,IAAeZ,SAAAA,EAAKY,MAAM,CAAC,EAAG,GAAsBZ,EAChE,OAzPoB,KAC1B,MAJgBK,EAAYI,CAK9B,CAEA,IAAMI,EAAQ/B,GAAW,CAAC,SAAU,QAAQ,CAACgC,QAAQ,CAACT,GAAa,KAAYP,MAAA,CAAPR,GAAW,KAInF,GAFIR,GAAWoB,GAAS,EAAGa,EAASF,GAsJxC5B,GArJgB4B,EACRR,UAAAA,EAAuB,CACzB,IAAMW,EAAY,CAAC,EAGnB,IAAK,IAAIR,EAAI,EAAGA,EAAIF,EAAaE,IAAK,CACpC,IAAMS,EAAOC,OAAOD,IAAI,CAACpC,CAAK,CAAC2B,EAAE,EACjC,IAAK,IAAMW,KAAKF,EAAM,CACpB,IAAIG,EAAUH,CAAI,CAACE,EAAE,CACrB,GAAMC,KAAWJ,EAKV,CACL,IAAMK,EAAgBL,CAAS,CAACI,EAAQ,CAACE,KAAK,CACxCC,EAAe1C,CAAK,CAAC2B,EAAE,CAACY,EAAQ,CAElCI,CAsTlB,SAAwBC,CAAO,CAAEC,CAAO,EACtC,IAAMC,EAAS,kBACf,OACET,OAAOU,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACL,KAAaE,GAC5CT,OAAOU,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACJ,KAAaC,CAEhD,GA5TiCN,EAAeE,IAK5B,CAJqBQ,EACvBb,OAAOD,IAAI,CAACM,GACZL,OAAOD,IAAI,CAACI,KAIZL,CAAAA,CAAS,CADTI,EAAU,GAAcY,MAAAA,CAAXZ,EAAQ,KAAYtB,MAAA,CA2R1C,uCAAuCL,OAAO,CAAC,QAAS,SAAUwC,CAAC,EACxE,IAAIC,EAAIC,GAAAA,KAAMC,MAAM,GAAW,EAE/B,MAAOC,CADDJ,KAAAA,EAAWC,EAAIA,EAAAA,EAAY,GACxBL,QAAQ,CAAC,GACpB,IA9RkC,CAAG,CACnBP,MAAOC,EACPe,MAAO,CACT,EAGN,MArBEtB,CAAS,CAACI,EAAQ,CAAG,CACnBE,MAAOzC,CAAK,CAAC2B,EAAE,CAACY,EAAQ,CACxBkB,MAAO,CACT,CAmBFtB,CAAAA,CAAS,CAACI,EAAQ,CAACkB,KAAK,EAC1B,CACF,CAIA,IAAMrB,EAAOC,OAAOD,IAAI,CAACD,GACvBuB,EAAS,CAAC,EACVC,EAAY,CAAC,EACf,IAAK,IAAMrB,KAAKF,EAAM,CACpB,IAAMG,EAAUH,CAAI,CAACE,EAAE,CACrBsB,EAAOzB,CAAS,CAACI,EAAQ,CAE3BmB,CAAM,CAACnB,EAAQ,CAAGqB,EAAKnB,KAAK,CAC5BkB,CAAS,CAACpB,EAAQ,CAAGqB,EAAKH,KAAK,EAAIhC,CACrC,CACAoC,EAAYxC,EAAQ,EAxFV,EAwFwBqC,EAAQC,EAC5C,KAAWnC,SAAAA,EACTN,EAAWlB,CAAK,CAAC,EAAE,CAAEqB,GAEjBpB,GAAWoB,GAAS,EACtBa,EAASV,GAAa,OAgG9BpB,GA9FeoB,GAAa,KAG1B,MACMvB,IACEoB,GAAS,EACXa,EAASzB,GAwFjBL,GAtFeK,GAGXoD,EAAYxC,EAAQ,EA1GR,EA0GsBrB,QAGhCC,GAAWoB,GAAS,EACtBa,EAASL,EAAO7B,KA8ENoB,EA5EHS,EAAO7B,GA6ElBI,GAAMgB,EA1ER,CAEA,SAASyC,EAAYxC,CAAK,CAAEyC,CAAS,CAAE9D,CAAK,CAAE2D,CAAS,EACjD1D,GACFM,EAAMwD,IAAI,CAAC1C,GAAS,EAAI,KAAO,IAGjC,IAAM2C,EAAgB,EAAE,CAExB,GAAI/D,GAAWoB,GAAS,EAAG,CACzB,IAAM4C,EAAa,QAAehD,MAAA,CAAPR,GACrByD,EAAYC,SA0QG/B,CAAI,EAC3B,IAAK,IAAMT,KAAKS,EACdA,CAAI,CAACT,EAAE,CAAGX,EAAOoB,CAAI,CAACT,EAAE,EAE1B,OAAOS,CACT,EA/QsCC,OAAOD,IAAI,CAACpC,IAK9C,GAAIS,KAAUH,GAAQ4C,EAAkBgB,EAAW5D,CAAI,CAACG,EAAO,EAAG,CAChEF,EAAM6D,GAAG,GACT,MACF,CACA9D,CAAI,CAACG,EAAO,CAAGyD,EAEfhC,EAAS,GAAcjB,MAAA,CAAXgD,EAAW,gBACvB,EAAEH,EACF,IAAM1B,EAAOC,OAAOD,IAAI,CAACpC,GACzB,IAAK,IAAM2B,KAAKS,EAAM,CACpB,IAAMG,EAAU8B,EAAgBjC,CAAI,CAACT,EAAE,EACvC2C,EAASR,GACT,IAAM/D,EAAWwE,EAAevD,EAAOuB,GAAUyB,GACjDA,EAAcD,IAAI,CAAChE,GAEnBmC,EAASnC,EAAW,KACpBU,EAASV,EACTmB,EAAWlB,CAAK,CAACoC,CAAI,CAACT,EAAE,CAAC,CAAEN,GAC3Ba,EAAS,WAAaK,GAClBpC,CAAAA,GAAiBwD,GAAaA,CAAuB,IAAvBA,CAAS,CAACvB,CAAI,CAACT,EAAE,CAAC,GAClDO,EAAS,cAEXA,EAAS,OACX,CACAoC,EAAS,EAAER,GACX5B,EAAS,IACX,KAAO,CAgCP9B,GA/BS,aACP,EAAEC,EACF,IAAM+B,EAAOC,OAAOD,IAAI,CAACpC,GACzB,IAAK,IAAM2B,KAAKS,EAAM,KA2BVhB,EA1BV,IAAMmB,EAAU8B,EAAgBjC,CAAI,CAACT,EAAE,EACvC6C,EAAOnE,GACP,IAAMN,EAAWwE,EAAevD,EAAOuB,GAAUyB,GACjDA,EAAcD,IAAI,CAAChE,GAwBvBK,GAvBWL,EAAW,IAClBU,EAASV,EACTmB,EAAWlB,CAAK,CAACoC,CAAI,CAACT,EAAE,CAAC,CAAEN,GAqB/BjB,GApBW,WAAamC,EAChBpC,CAAAA,GAAiBwD,GAAaA,CAAuB,IAAvBA,CAAS,CAACvB,CAAI,CAACT,EAAE,CAAC,GAmBxDvB,CAAAA,GAlBa,YAkBPgB,EAhBElB,GAAWF,KAAAA,CAAK,CAACoC,CAAI,CAACT,EAAE,CAAC,EAAW,iBAAO3B,CAAK,CAACoC,CAAI,CAACT,EAAE,CAAC,GAenDP,EAdD,cAAgBpB,CAAK,CAACoC,CAAI,CAACT,EAAE,CAAC,CAe3CvB,GAAMgB,GAANhB,GAbW,MACT,CACAoE,EAAO,EAAEnE,GAWXD,GAVS,GACT,CACIH,GAASO,CAAAA,GAAeD,EAAM6D,GAAG,GACvC,CAEA,SAASI,EAAOnE,CAAI,EAClB,IAAK,IAAIsB,EAAI,EAAGA,EAAItB,EAAMsB,IAAKvB,GAAM,GACvC,CAMA,SAASkE,EAASjE,CAAI,EACpB,IAAK,IAAIsB,EAAI,EAAGA,EAAItB,EAAMsB,IAAKpB,CAAK,CAACA,EAAMmB,MAAM,CAAG,EAAE,EAAI,GAC5D,CAEA,SAASQ,EAASd,CAAG,EACnBb,CAAK,CAACA,EAAMmB,MAAM,CAAG,EAAE,EAAIN,CAC7B,CAIA,SAASmD,EAAeE,CAAI,CAAEnE,CAAI,EAChC,GAAIA,KAAAA,EAAKoE,OAAO,CAACD,GACf,OAAOA,EAGT,IAAI9C,EAAI,EACR,OAAa,CACX,IAAMgD,EAAUF,EAAO9C,EAAEqB,QAAQ,GACjC,GAAI1C,KAAAA,EAAKoE,OAAO,CAACC,GACf,OAAOA,CAGThD,CAAAA,GACF,CACF,CAGA,SAASX,EAAOI,CAAG,EAGjB,IAAMwD,EAAYC,CAgEpB,SAAsBzD,CAAG,EAEnBA,EAAI0D,KAAK,CAAC,iBACZ1D,CAAAA,EAAMA,EAAI2D,WAAW,IAIvB,IAAMC,EAAoB,CACxB,MACA,MACA,QACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,QACA,KACA,KACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,OACA,MACA,MACA,OACA,KACA,MACA,OACA,OACA,MACD,CAED,OAAO5D,EACJR,OAAO,CAAC,yBAA0B,SAAUqE,CAAM,CAAEC,CAAG,CAAEC,CAAI,SAC5D,EAAsBT,OAAO,CAACS,EAAKC,WAAW,KAAO,EAAUF,EAAMC,EAAKC,WAAW,GACzEF,EAAMC,CAAI,CAAC,EAAE,CAACC,WAAW,GAAKD,EAAKpD,MAAM,CAAC,GAAGgD,WAAW,EACtE,GACCnE,OAAO,CAAC,mBAAoB,SAAUqE,CAAM,CAAEC,CAAG,CAAEC,CAAI,SACtD,EAAsBT,OAAO,CAACQ,EAAMC,EAAKC,WAAW,KAAO,EAClD,CAACF,EAAMC,CAAAA,EAAMC,WAAW,GACrBF,EAAMC,CACpB,EACJ,GA5HE/D,EAAMiE,EAAajE,IAEiBR,OAAO,CAAC,cAAe,WAC3D,EAMOyE,EAAaT,GALX,eAMX,CAGA,SAASS,EAAajE,CAAG,SACvB,GACSA,EAAI0D,KAAK,CAAC,SAAU1D,EAAM,MAAQA,EAClCA,EAAIkE,MAAM,CAAC,GAAGR,KAAK,CAAC,OAa3B1D,CAAAA,EAAMmE,CAZU,CACd,EAAG,QACH,EAAG,OACH,EAAG,OACH,EAAG,SACH,EAAG,QACH,EAAG,QACH,EAAG,OACH,EAAG,SACH,EAAG,SACH,EAAG,OACL,EACa,CAACnE,EAAIkE,MAAM,CAAC,GAAG,CAAGlE,EAAIW,MAAM,CAAC,IAGrCX,GAlBU,EAmBnB,CAGA,SAASS,EAAO2D,CAAG,EACjB,GAAIA,OAAAA,EAAc,MAAO,MAEzB,OAAQ,OAAOA,GACb,IAAK,SACH,GAAI,wDAAwDC,IAAI,CAACD,GAAM,MAAO,YACzE,MAAO,QACd,KAAK,SACH,GAAIA,EAAM,GAAM,EAGT,MAAO,UAFZ,GAAIA,EAAM,aAAeA,EAAM,WAAY,MAAO,MAC7C,MAAO,OAEhB,KAAK,UACH,MAAO,MACT,KAAK,SACH,GAAIlE,MAAMC,OAAO,CAACiE,GAAM,MAAO,QAC/B,MAAO,QACT,SACE,MAAO,KACX,CACF,CA8EA,SAASnB,EAAgBqB,CAAM,EAK7B,GAAIA,EAAOhE,MAAM,EAFE,GAEc,CAC/B,IAAMiE,EAAOD,EAAO3D,MAAM,CAAC,KAC3B,GAAI6D,6EAAcH,IAAI,CAACE,GACrB,OAAOD,EAAO1D,KAAK,CAAC,EAAG,IAE3B,CACA,OAAO0D,CACT,CAUA,SAASxC,EAAkB2C,CAAS,CAAEC,CAAS,EAC7C,IAAMC,EAAUF,EAAUnE,MAAM,CAC1BsE,EAAUF,EAAUpE,MAAM,CAGhC,GAAIqE,GAAAA,GAAgBC,GAAAA,EAAc,MAAO,GAGzC,GAAID,GAAWC,EAAS,MAAO,GAE/B,IAAK,IAAMC,KAAQJ,EACjB,GAAI,CAACC,EAAU7D,QAAQ,CAACgE,GAAO,MAAO,GAExC,MAAO,EACT,CAQF","sources":["webpack://_N_E/./src/lib/utils/json2go.js"],"sourcesContent":["/*\n\tJSON-to-Go\n\tby Matt Holt\n\n\thttps://github.com/mholt/json-to-go\n\n\tA simple utility to translate JSON into a Go type definition.\n*/\n\nfunction jsonToGo(json, typename, flatten = true, example = false, allOmitempty = false) {\n  let data;\n  let scope;\n  let go = \"\";\n  let tabs = 0;\n\n  const seen = {};\n  const stack = [];\n  let accumulator = \"\";\n  const innerTabs = 0;\n  let parent = \"\";\n\n  try {\n    data = JSON.parse(json.replace(/(:\\s*\\[?\\s*-?\\d*)\\.0/g, \"$1.1\")); // hack that forces floats to stay as floats\n    scope = data;\n  } catch (e) {\n    return {\n      go: \"\",\n      error: e.message,\n    };\n  }\n\n  typename = format(typename || \"Root\");\n  append(`type ${typename} `);\n\n  parseScope(scope);\n\n  return {\n    go: flatten ? (go += accumulator) : go,\n  };\n\n  function parseScope(scope, depth = 0) {\n    if (typeof scope === \"object\" && scope !== null) {\n      if (Array.isArray(scope)) {\n        let sliceType;\n        const scopeLength = scope.length;\n\n        for (let i = 0; i < scopeLength; i++) {\n          const thisType = goType(scope[i]);\n          if (!sliceType) sliceType = thisType;\n          else if (sliceType != thisType) {\n            sliceType = mostSpecificPossibleGoType(thisType, sliceType);\n            if (sliceType == \"any\") break;\n          }\n        }\n\n        const slice = flatten && [\"struct\", \"slice\"].includes(sliceType) ? `[]${parent}` : \"[]\";\n\n        if (flatten && depth >= 2) appender(slice);\n        else append(slice);\n        if (sliceType == \"struct\") {\n          const allFields = {};\n\n          // for each field counts how many times appears\n          for (let i = 0; i < scopeLength; i++) {\n            const keys = Object.keys(scope[i]);\n            for (const k in keys) {\n              let keyname = keys[k];\n              if (!(keyname in allFields)) {\n                allFields[keyname] = {\n                  value: scope[i][keyname],\n                  count: 0,\n                };\n              } else {\n                const existingValue = allFields[keyname].value;\n                const currentValue = scope[i][keyname];\n\n                if (compareObjects(existingValue, currentValue)) {\n                  const comparisonResult = compareObjectKeys(\n                    Object.keys(currentValue),\n                    Object.keys(existingValue)\n                  );\n                  if (!comparisonResult) {\n                    keyname = `${keyname}_${uuidv4()}`;\n                    allFields[keyname] = {\n                      value: currentValue,\n                      count: 0,\n                    };\n                  }\n                }\n              }\n              allFields[keyname].count++;\n            }\n          }\n\n          // create a common struct with all fields found in the current array\n          // omitempty dict indicates if a field is optional\n          const keys = Object.keys(allFields),\n            struct = {},\n            omitempty = {};\n          for (const k in keys) {\n            const keyname = keys[k],\n              elem = allFields[keyname];\n\n            struct[keyname] = elem.value;\n            omitempty[keyname] = elem.count != scopeLength;\n          }\n          parseStruct(depth + 1, innerTabs, struct, omitempty); // finally parse the struct !!\n        } else if (sliceType == \"slice\") {\n          parseScope(scope[0], depth);\n        } else {\n          if (flatten && depth >= 2) {\n            appender(sliceType || \"any\");\n          } else {\n            append(sliceType || \"any\");\n          }\n        }\n      } else {\n        if (flatten) {\n          if (depth >= 2) {\n            appender(parent);\n          } else {\n            append(parent);\n          }\n        }\n        parseStruct(depth + 1, innerTabs, scope);\n      }\n    } else {\n      if (flatten && depth >= 2) {\n        appender(goType(scope));\n      } else {\n        append(goType(scope));\n      }\n    }\n  }\n\n  function parseStruct(depth, innerTabs, scope, omitempty) {\n    if (flatten) {\n      stack.push(depth >= 2 ? \"\\n\" : \"\");\n    }\n\n    const seenTypeNames = [];\n\n    if (flatten && depth >= 2) {\n      const parentType = `type ${parent}`;\n      const scopeKeys = formatScopeKeys(Object.keys(scope));\n\n      // this can only handle two duplicate items\n      // future improvement will handle the case where there could\n      // three or more duplicate keys with different values\n      if (parent in seen && compareObjectKeys(scopeKeys, seen[parent])) {\n        stack.pop();\n        return;\n      }\n      seen[parent] = scopeKeys;\n\n      appender(`${parentType} struct {\\n`);\n      ++innerTabs;\n      const keys = Object.keys(scope);\n      for (const i in keys) {\n        const keyname = getOriginalName(keys[i]);\n        indenter(innerTabs);\n        const typename = uniqueTypeName(format(keyname), seenTypeNames);\n        seenTypeNames.push(typename);\n\n        appender(typename + \" \");\n        parent = typename;\n        parseScope(scope[keys[i]], depth);\n        appender(' `json:\"' + keyname);\n        if (allOmitempty || (omitempty && omitempty[keys[i]] === true)) {\n          appender(\",omitempty\");\n        }\n        appender('\"`\\n');\n      }\n      indenter(--innerTabs);\n      appender(\"}\");\n    } else {\n      append(\"struct {\\n\");\n      ++tabs;\n      const keys = Object.keys(scope);\n      for (const i in keys) {\n        const keyname = getOriginalName(keys[i]);\n        indent(tabs);\n        const typename = uniqueTypeName(format(keyname), seenTypeNames);\n        seenTypeNames.push(typename);\n        append(typename + \" \");\n        parent = typename;\n        parseScope(scope[keys[i]], depth);\n        append(' `json:\"' + keyname);\n        if (allOmitempty || (omitempty && omitempty[keys[i]] === true)) {\n          append(\",omitempty\");\n        }\n        if (example && scope[keys[i]] !== \"\" && typeof scope[keys[i]] !== \"object\") {\n          append('\" example:\"' + scope[keys[i]]);\n        }\n        append('\"`\\n');\n      }\n      indent(--tabs);\n      append(\"}\");\n    }\n    if (flatten) accumulator += stack.pop();\n  }\n\n  function indent(tabs) {\n    for (let i = 0; i < tabs; i++) go += \"\\t\";\n  }\n\n  function append(str) {\n    go += str;\n  }\n\n  function indenter(tabs) {\n    for (let i = 0; i < tabs; i++) stack[stack.length - 1] += \"\\t\";\n  }\n\n  function appender(str) {\n    stack[stack.length - 1] += str;\n  }\n\n  // Generate a unique name to avoid duplicate struct field names.\n  // This function appends a number at the end of the field name.\n  function uniqueTypeName(name, seen) {\n    if (seen.indexOf(name) === -1) {\n      return name;\n    }\n\n    let i = 0;\n    while (true) {\n      const newName = name + i.toString();\n      if (seen.indexOf(newName) === -1) {\n        return newName;\n      }\n\n      i++;\n    }\n  }\n\n  // Sanitizes and formats a string to make an appropriate identifier in Go\n  function format(str) {\n    str = formatNumber(str);\n\n    const sanitized = toProperCase(str).replace(/[^a-z0-9]/gi, \"\");\n    if (!sanitized) {\n      return \"NAMING_FAILED\";\n    }\n\n    // After sanitizing the remaining characters can start with a number.\n    // Run the sanitized string again trough formatNumber to make sure the identifier is Num[0-9] or Zero_... instead of 1.\n    return formatNumber(sanitized);\n  }\n\n  // Adds a prefix to a number to make an appropriate identifier in Go\n  function formatNumber(str) {\n    if (!str) return \"\";\n    else if (str.match(/^\\d+$/)) str = \"Num\" + str;\n    else if (str.charAt(0).match(/\\d/)) {\n      const numbers = {\n        0: \"Zero_\",\n        1: \"One_\",\n        2: \"Two_\",\n        3: \"Three_\",\n        4: \"Four_\",\n        5: \"Five_\",\n        6: \"Six_\",\n        7: \"Seven_\",\n        8: \"Eight_\",\n        9: \"Nine_\",\n      };\n      str = numbers[str.charAt(0)] + str.substr(1);\n    }\n\n    return str;\n  }\n\n  // Determines the most appropriate Go type\n  function goType(val) {\n    if (val === null) return \"any\";\n\n    switch (typeof val) {\n      case \"string\":\n        if (/\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d+)?(\\+\\d\\d:\\d\\d|Z)/.test(val)) return \"time.Time\";\n        else return \"string\";\n      case \"number\":\n        if (val % 1 === 0) {\n          if (val > -2147483648 && val < 2147483647) return \"int\";\n          else return \"int64\";\n        } else return \"float64\";\n      case \"boolean\":\n        return \"bool\";\n      case \"object\":\n        if (Array.isArray(val)) return \"slice\";\n        return \"struct\";\n      default:\n        return \"any\";\n    }\n  }\n\n  // Given two types, returns the more specific of the two\n  function mostSpecificPossibleGoType(typ1, typ2) {\n    if (typ1.substr(0, 5) == \"float\" && typ2.substr(0, 3) == \"int\") return typ1;\n    else if (typ1.substr(0, 3) == \"int\" && typ2.substr(0, 5) == \"float\") return typ2;\n    else return \"any\";\n  }\n\n  // Proper cases a string according to Go conventions\n  function toProperCase(str) {\n    // ensure that the SCREAMING_SNAKE_CASE is converted to snake_case\n    if (str.match(/^[_A-Z0-9]+$/)) {\n      str = str.toLowerCase();\n    }\n\n    // https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810\n    const commonInitialisms = [\n      \"ACL\",\n      \"API\",\n      \"ASCII\",\n      \"CPU\",\n      \"CSS\",\n      \"DNS\",\n      \"EOF\",\n      \"GUID\",\n      \"HTML\",\n      \"HTTP\",\n      \"HTTPS\",\n      \"ID\",\n      \"IP\",\n      \"JSON\",\n      \"LHS\",\n      \"QPS\",\n      \"RAM\",\n      \"RHS\",\n      \"RPC\",\n      \"SLA\",\n      \"SMTP\",\n      \"SQL\",\n      \"SSH\",\n      \"TCP\",\n      \"TLS\",\n      \"TTL\",\n      \"UDP\",\n      \"UI\",\n      \"UID\",\n      \"UUID\",\n      \"URI\",\n      \"URL\",\n      \"UTF8\",\n      \"VM\",\n      \"XML\",\n      \"XMPP\",\n      \"XSRF\",\n      \"XSS\",\n    ];\n\n    return str\n      .replace(/(^|[^a-zA-Z])([a-z]+)/g, function (unused, sep, frag) {\n        if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0) return sep + frag.toUpperCase();\n        else return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();\n      })\n      .replace(/([A-Z])([a-z]+)/g, function (unused, sep, frag) {\n        if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)\n          return (sep + frag).toUpperCase();\n        else return sep + frag;\n      });\n  }\n\n  function uuidv4() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n      var r = (Math.random() * 16) | 0,\n        v = c == \"x\" ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n\n  function getOriginalName(unique) {\n    const reLiteralUUID =\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    const uuidLength = 36;\n\n    if (unique.length >= uuidLength) {\n      const tail = unique.substr(-uuidLength);\n      if (reLiteralUUID.test(tail)) {\n        return unique.slice(0, -1 * (uuidLength + 1));\n      }\n    }\n    return unique;\n  }\n\n  function compareObjects(objectA, objectB) {\n    const object = \"[object Object]\";\n    return (\n      Object.prototype.toString.call(objectA) === object &&\n      Object.prototype.toString.call(objectB) === object\n    );\n  }\n\n  function compareObjectKeys(itemAKeys, itemBKeys) {\n    const lengthA = itemAKeys.length;\n    const lengthB = itemBKeys.length;\n\n    // nothing to compare, probably identical\n    if (lengthA == 0 && lengthB == 0) return true;\n\n    // duh\n    if (lengthA != lengthB) return false;\n\n    for (const item of itemAKeys) {\n      if (!itemBKeys.includes(item)) return false;\n    }\n    return true;\n  }\n\n  function formatScopeKeys(keys) {\n    for (const i in keys) {\n      keys[i] = format(keys[i]);\n    }\n    return keys;\n  }\n}\n\nif (typeof module != \"undefined\") {\n  module.exports = jsonToGo;\n}\n"],"names":["module","exports","json","typename","scope","flatten","example","allOmitempty","go","tabs","seen","stack","accumulator","parent","JSON","parse","replace","e","error","message","format","concat","parseScope","typ2","str","depth","Array","isArray","sliceType","scopeLength","length","i","thisType","goType","typ1","substr","slice","includes","appender","allFields","keys","Object","k","keyname","existingValue","value","currentValue","compareObjects","objectA","objectB","object","prototype","toString","call","compareObjectKeys","uuidv4","c","r","Math","random","v","count","struct","omitempty","elem","parseStruct","innerTabs","push","seenTypeNames","parentType","scopeKeys","formatScopeKeys","pop","getOriginalName","indenter","uniqueTypeName","indent","name","indexOf","newName","sanitized","toProperCase","match","toLowerCase","commonInitialisms","unused","sep","frag","toUpperCase","formatNumber","charAt","numbers","val","test","unique","tail","reLiteralUUID","itemAKeys","itemBKeys","lengthA","lengthB","item"],"sourceRoot":""}