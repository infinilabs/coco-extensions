{"version":3,"file":"static/chunks/352.d4f879ec51a18602.js","mappings":"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","sources":["webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/util.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/validator.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","webpack://_N_E/./node_modules/.pnpm/strnum@2.1.1/node_modules/strnum/strnum.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/ignoreAttributes.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlparser/node2json.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","webpack://_N_E/./node_modules/.pnpm/fast-xml-parser@5.2.3/node_modules/fast-xml-parser/src/fxp.js"],"sourcesContent":["'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nexport const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nexport function getAllMatches(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n}\n\nexport const isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n}\n\nexport function isExist(v) {\n  return typeof v !== 'undefined';\n}\n\nexport function isEmptyObject(obj) {\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexport function merge(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n}\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexport function getValue(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n}\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};","'use strict';\n\nimport {getAllMatches, isName} from './util.js';\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexport function validate(xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else if (tags.length === 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","\nexport const defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n    captureMetaData: false,\n};\n   \nexport const buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n","'use strict';\n\nlet METADATA_SYMBOL;\n\nif (typeof Symbol !== \"function\") {\n  METADATA_SYMBOL = \"@@xmlMetadata\";\n} else {\n  METADATA_SYMBOL = Symbol(\"XML Node Metadata\");\n}\n\nexport default class XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node, startIndex) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n    // if requested, add the startIndex\n    if (startIndex !== undefined) {\n      // Note: for now we just overwrite the metadata. If we had more complex metadata,\n      // we might need to do an object append here:  metadata = { ...metadata, startIndex }\n      this.child[this.child.length - 1][METADATA_SYMBOL] = { startIndex };\n    }\n  }\n  /** symbol used for metadata */\n  static getMetaDataSymbol() {\n    return METADATA_SYMBOL;\n  }\n}\n","import {isName} from '../util.js';\n\n//TODO: handle comments\nexport default function readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && hasSeq(xmlData, \"!ENTITY\",i)){\n                    i += 7; \n                    let entityName, val;\n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ entityName ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && hasSeq(xmlData, \"!ELEMENT\",i))  {\n                    i += 8;//Not supported\n                    const {index} = readElementExp(xmlData,i+1);\n                    i = index;\n                }else if( hasBody && hasSeq(xmlData, \"!ATTLIST\",i)){\n                    i += 8;//Not supported\n                    // const {index} = readAttlistExp(xmlData,i+1);\n                    // i = index;\n                }else if( hasBody && hasSeq(xmlData, \"!NOTATION\",i)) {\n                    i += 9;//Not supported\n                    const {index} = readNotationExp(xmlData,i+1);\n                    i = index;\n                }else if( hasSeq(xmlData, \"!--\",i) ) comment = true;\n                else throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nconst skipWhitespace = (data, index) => {\n    while (index < data.length && /\\s/.test(data[index])) {\n        index++;\n    }\n    return index;\n};\n\nfunction readEntityExp(xmlData, i) {    \n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n\n    // Skip leading whitespace after <!ENTITY\n    i = skipWhitespace(xmlData, i);\n\n    // Read entity name\n    let entityName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\") {\n        entityName += xmlData[i];\n        i++;\n    }\n    validateEntityName(entityName);\n\n    // Skip whitespace after entity name\n    i = skipWhitespace(xmlData, i);\n\n    // Check for unsupported constructs (external entities or parameter entities)\n    if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n        throw new Error(\"External entities are not supported\");\n    }else if (xmlData[i] === \"%\") {\n        throw new Error(\"Parameter entities are not supported\");\n    }\n\n    // Read entity value (internal entity)\n    let entityValue = \"\";\n    [i, entityValue] = readIdentifierVal(xmlData, i, \"entity\");\n    i--;\n    return [entityName, entityValue, i ];\n}\n\nfunction readNotationExp(xmlData, i) {\n    // Skip leading whitespace after <!NOTATION\n    i = skipWhitespace(xmlData, i);\n\n    // Read notation name\n    let notationName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        notationName += xmlData[i];\n        i++;\n    }\n    validateEntityName(notationName);\n\n    // Skip whitespace after notation name\n    i = skipWhitespace(xmlData, i);\n\n    // Check identifier type (SYSTEM or PUBLIC)\n    const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n    if (identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n        throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n    }\n    i += identifierType.length;\n\n    // Skip whitespace after identifier type\n    i = skipWhitespace(xmlData, i);\n\n    // Read public identifier (if PUBLIC)\n    let publicIdentifier = null;\n    let systemIdentifier = null;\n\n    if (identifierType === \"PUBLIC\") {\n        [i, publicIdentifier ] = readIdentifierVal(xmlData, i, \"publicIdentifier\");\n\n        // Skip whitespace after public identifier\n        i = skipWhitespace(xmlData, i);\n\n        // Optionally read system identifier\n        if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n            [i, systemIdentifier ] = readIdentifierVal(xmlData, i,\"systemIdentifier\");\n        }\n    } else if (identifierType === \"SYSTEM\") {\n        // Read system identifier (mandatory for SYSTEM)\n        [i, systemIdentifier ] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n\n        if (!systemIdentifier) {\n            throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n        }\n    }\n    \n    return {notationName, publicIdentifier, systemIdentifier, index: --i};\n}\n\nfunction readIdentifierVal(xmlData, i, type) {\n    let identifierVal = \"\";\n    const startChar = xmlData[i];\n    if (startChar !== '\"' && startChar !== \"'\") {\n        throw new Error(`Expected quoted string, found \"${startChar}\"`);\n    }\n    i++;\n\n    while (i < xmlData.length && xmlData[i] !== startChar) {\n        identifierVal += xmlData[i];\n        i++;\n    }\n\n    if (xmlData[i] !== startChar) {\n        throw new Error(`Unterminated ${type} value`);\n    }\n    i++;\n    return [i, identifierVal];\n}\n\nfunction readElementExp(xmlData, i) {\n    // <!ELEMENT br EMPTY>\n    // <!ELEMENT div ANY>\n    // <!ELEMENT title (#PCDATA)>\n    // <!ELEMENT book (title, author+)>\n    // <!ELEMENT name (content-model)>\n    \n    // Skip leading whitespace after <!ELEMENT\n    i = skipWhitespace(xmlData, i);\n\n    // Read element name\n    let elementName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        elementName += xmlData[i];\n        i++;\n    }\n\n    // Validate element name\n    if (!validateEntityName(elementName)) {\n        throw new Error(`Invalid element name: \"${elementName}\"`);\n    }\n\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n    let contentModel = \"\";\n    // Expect '(' to start content model\n    if(xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\",i)) i+=6;\n    else if(xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\",i)) i+=4;\n    else if (xmlData[i] === \"(\") {\n        i++; // Move past '('\n\n        // Read content model\n        while (i < xmlData.length && xmlData[i] !== \")\") {\n            contentModel += xmlData[i];\n            i++;\n        }\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated content model\");\n        }\n\n    }else{\n        throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n    }\n    \n    return {\n        elementName,\n        contentModel: contentModel.trim(),\n        index: i\n    };\n}\n\nfunction readAttlistExp(xmlData, i) {\n    // Skip leading whitespace after <!ATTLIST\n    i = skipWhitespace(xmlData, i);\n\n    // Read element name\n    let elementName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        elementName += xmlData[i];\n        i++;\n    }\n\n    // Validate element name\n    validateEntityName(elementName)\n\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n\n    // Read attribute name\n    let attributeName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        attributeName += xmlData[i];\n        i++;\n    }\n\n    // Validate attribute name\n    if (!validateEntityName(attributeName)) {\n        throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n    }\n\n    // Skip whitespace after attribute name\n    i = skipWhitespace(xmlData, i);\n\n    // Read attribute type\n    let attributeType = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n        attributeType = \"NOTATION\";\n        i += 8; // Move past \"NOTATION\"\n\n        // Skip whitespace after \"NOTATION\"\n        i = skipWhitespace(xmlData, i);\n\n        // Expect '(' to start the list of notations\n        if (xmlData[i] !== \"(\") {\n            throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n        }\n        i++; // Move past '('\n\n        // Read the list of allowed notations\n        let allowedNotations = [];\n        while (i < xmlData.length && xmlData[i] !== \")\") {\n            let notation = \"\";\n            while (i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\") {\n                notation += xmlData[i];\n                i++;\n            }\n\n            // Validate notation name\n            notation = notation.trim();\n            if (!validateEntityName(notation)) {\n                throw new Error(`Invalid notation name: \"${notation}\"`);\n            }\n\n            allowedNotations.push(notation);\n\n            // Skip '|' separator or exit loop\n            if (xmlData[i] === \"|\") {\n                i++; // Move past '|'\n                i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n            }\n        }\n\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated list of notations\");\n        }\n        i++; // Move past ')'\n\n        // Store the allowed notations as part of the attribute type\n        attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n    } else {\n        // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            attributeType += xmlData[i];\n            i++;\n        }\n\n        // Validate simple attribute type\n        const validTypes = [\"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"ENTITY\", \"ENTITIES\", \"NMTOKEN\", \"NMTOKENS\"];\n        if (!validTypes.includes(attributeType.toUpperCase())) {\n            throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n        }\n    }\n\n    // Skip whitespace after attribute type\n    i = skipWhitespace(xmlData, i);\n\n    // Read default value\n    let defaultValue = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n        defaultValue = \"#REQUIRED\";\n        i += 8;\n    } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n        defaultValue = \"#IMPLIED\";\n        i += 7;\n    } else {\n        [i, defaultValue] = readIdentifierVal(xmlData, i, \"ATTLIST\");\n    }\n\n    return {\n        elementName,\n        attributeName,\n        attributeType,\n        defaultValue,\n        index: i\n    }\n}\n\nfunction hasSeq(data, seq,i){\n    for(let j=0;j<seq.length;j++){\n        if(seq[j]!==data[i+j+1]) return false;\n    }\n    return true;\n}\n\nfunction validateEntityName(name){\n    if (isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nexport default function toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.search(/.+[eE].+/)!== -1) { //eNotation\n        return resolveEnotation(str,trimmedStr,options);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1] || \"\";\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            const decimalAdjacentToLeadingZeros = sign ? // 0., -00., 000.\n                str[leadingZeros.length+1] === \".\" \n                : str[leadingZeros.length] === \".\";\n\n            //trim ending zeros for floating number\n            if(!options.leadingZeros //leading zeros are not allowed\n                && (leadingZeros.length > 1 \n                    || (leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros))){\n                // 00, 00.3, +03.24, 03, 03.24\n                return str;\n            }\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const parsedStr = String(num);\n\n                if( num === 0) return num;\n                if(parsedStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(parsedStr === \"0\") return num; //0.0\n                    else if(parsedStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( parsedStr === `${sign}${numTrimmedByZeros}`) return num;\n                    else return str;\n                }\n                \n                let n = leadingZeros? numTrimmedByZeros : trimmedStr;\n                if(leadingZeros){\n                    // -009 => -9\n                    return (n === parsedStr) || (sign+n === parsedStr) ? num : str\n                }else  {\n                    // +9\n                    return (n === parsedStr) || (n === sign+parsedStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\nconst eNotationRegx = /^([-+])?(0*)(\\d*(\\.\\d*)?[eE][-\\+]?\\d+)$/;\nfunction resolveEnotation(str,trimmedStr,options){\n    if(!options.eNotation) return str;\n    const notation = trimmedStr.match(eNotationRegx); \n    if(notation){\n        let sign = notation[1] || \"\";\n        const eChar = notation[3].indexOf(\"e\") === -1 ? \"E\" : \"e\";\n        const leadingZeros = notation[2];\n        const eAdjacentToLeadingZeros = sign ? // 0E.\n            str[leadingZeros.length+1] === eChar \n            : str[leadingZeros.length] === eChar;\n\n        if(leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;\n        else if(leadingZeros.length === 1 \n            && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)){\n                return Number(trimmedStr);\n        }else if(options.leadingZeros && !eAdjacentToLeadingZeros){ //accept with leading zeros\n            //remove leading 0s\n            trimmedStr = (notation[1] || \"\") + notation[3];\n            return Number(trimmedStr);\n        }else return str;\n    }else{\n        return str;\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substring(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}","export default function getIgnoreAttributesFn(ignoreAttributes) {\n    if (typeof ignoreAttributes === 'function') {\n        return ignoreAttributes\n    }\n    if (Array.isArray(ignoreAttributes)) {\n        return (attrName) => {\n            for (const pattern of ignoreAttributes) {\n                if (typeof pattern === 'string' && attrName === pattern) {\n                    return true\n                }\n                if (pattern instanceof RegExp && pattern.test(attrName)) {\n                    return true\n                }\n            }\n        }\n    }\n    return () => false\n}","'use strict';\n///@ts-check\n\nimport {getAllMatches, isExist} from '../util.js';\nimport xmlNode from './xmlNode.js';\nimport readDocType from './DocTypeReader.js';\nimport toNumber from \"strnum\";\nimport getIgnoreAttributesFn from \"../ignoreAttributes.js\";\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nexport default class OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      if (this.ignoreAttributesFn(attrName, jPath)) {\n        continue\n      }\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath, i);\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        const startIndex = i;\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            \n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath, startIndex);\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath, startIndex){\n  // unset startIndex if not requested\n  if (!this.options.captureMetaData) startIndex = undefined;\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  } else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode, startIndex);\n  }else{\n    currentNode.addChild(childNode, startIndex);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = currentNode.child.length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n","'use strict';\n\nimport XmlNode from './xmlNode.js';\n\nconst METADATA_SYMBOL = XmlNode.getMetaDataSymbol();\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nexport default function prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n      if (tagObj[METADATA_SYMBOL] !== undefined) {\n        val[METADATA_SYMBOL] = tagObj[METADATA_SYMBOL]; // copy over metadata\n      }\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import { buildOptions} from './OptionsBuilder.js';\nimport OrderedObjParser from './OrderedObjParser.js';\nimport prettify from './node2json.js';\nimport {validate} from \"../validator.js\";\nimport XmlNode from './xmlNode.js';\n\nexport default class XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n\n    /**\n     * Returns a Symbol that can be used to access the metadata\n     * property on a node.\n     * \n     * If Symbol is not available in the environment, an ordinary property is used\n     * and the name of the property is here returned.\n     * \n     * The XMLMetaData property is only present when `captureMetaData`\n     * is true in the options.\n     */\n    static getMetaDataSymbol() {\n        return XmlNode.getMetaDataSymbol();\n    }\n}\n","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nexport default function toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\n","'use strict';\n//parse Empty Node as self closing node\nimport buildFromOrderedJs from './orderedJs2Xml.js';\nimport getIgnoreAttributesFn from \"../ignoreAttributes.js\";\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nexport default function Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0, []).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level, ajPath) {\n  let attrStr = '';\n  let val = '';\n  const jPath = ajPath.join('.')\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key === this.options.cdataPropName) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr && !this.ignoreAttributesFn(attr, jPath)) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      } else if (!attr) {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      let listTagAttr = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup){\n            const result = this.j2x(item, level + 1, ajPath.concat(key));\n            listTagVal += result.val;\n            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {\n              listTagAttr += result.attrStr\n            }\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level, ajPath)\n          }\n        } else {\n          if (this.options.oneListGroup) {\n            let textValue = this.options.tagValueProcessor(key, item);\n            textValue = this.replaceEntitiesValue(textValue);\n            listTagVal += textValue;\n          } else {\n            listTagVal += this.buildTextValNode(item, key, '', level);\n          }\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level, ajPath)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level, ajPath) {\n  const result = this.j2x(object, level + 1, ajPath.concat(key));\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\n","'use strict';\n\nimport {validate} from './validator.js';\nimport XMLParser from './xmlparser/XMLParser.js';\nimport XMLBuilder from './xmlbuilder/json2xml.js';\n\nconst XMLValidator = {\n  validate: validate\n}\nexport {\n  XMLParser,\n  XMLValidator,\n  XMLBuilder\n};"],"names":["METADATA_SYMBOL","nameStartChar","regexName","getAllMatches","string","regex","matches","match","exec","allmatches","startIndex","lastIndex","length","len","index","push","isName","defaultOptions","allowBooleanAttributes","unpairedTags","isWhiteSpace","char","readPI","xmlData","i","start","tagname","substr","getErrorObject","getLineNumberForPosition","readCommentAndCDATA","angleBracketsCount","validAttrStrRegxp","validateAttributeString","attrStr","options","attrNames","getPositionFromMatch","undefined","attrName","hasOwnProperty","code","message","lineNumber","err","msg","line","col","lines","substring","split","OptionsBuilder_defaultOptions","preserveOrder","attributeNamePrefix","attributesGroupName","textNodeName","ignoreAttributes","removeNSPrefix","parseTagValue","parseAttributeValue","trimValues","cdataPropName","numberParseOptions","hex","leadingZeros","eNotation","tagValueProcessor","tagName","val","attributeValueProcessor","stopNodes","alwaysCreateTextNode","isArray","commentPropName","processEntities","htmlEntities","ignoreDeclaration","ignorePiTags","transformTagName","transformAttributeName","updateTag","jPath","attrs","captureMetaData","Symbol","XmlNode","constructor","child","add","key","addChild","node","Object","keys","getMetaDataSymbol","skipWhitespace","data","test","readIdentifierVal","type","identifierVal","startChar","hasSeq","seq","j","validateEntityName","name","hexRegex","numRegex","consider","decimalPoint","eNotationRegx","getIgnoreAttributesFn","Array","pattern","RegExp","OrderedObjParser","currentNode","tagsNodeStack","docTypeEntities","lastEntities","ampEntity","_","str","String","fromCodePoint","Number","parseInt","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","ignoreAttributesFn","externalEntities","entKeys","ent","dontTrim","hasAttributes","isLeafNode","escapeEntities","trim","newval","parseValue","tags","prefix","charAt","attrsRegx","oldVal","aName","newVal","attrCollection","replace","xmlObj","textData","ch","closeIndex","findClosingIndex","colonIndex","indexOf","lastTagName","lastIndexOf","propIndex","pop","tagData","readTagExp","childNode","tagExp","attrExpPresent","endIndex","comment","result","readDocType","entities","hasBody","entityName","readEntityExp","toUpperCase","entityValue","regx","readElementExp","elementName","contentModel","readNotationExp","notationName","identifierType","publicIdentifier","systemIdentifier","rawTagName","lastTag","tagContent","entity","currentTagName","allNodesExp","stopNodePath","stopNodeExp","errMsg","closingIndex","closingChar","tagExpWithClosingIndex","attrBoundary","separatorIndex","search","trimStart","openTagCount","closeTagName","shouldParse","toNumber","assign","trimmedStr","skipLike","parse_int","numStr","base","window","resolveEnotation","notation","sign","eChar","eAdjacentToLeadingZeros","startsWith","numTrimmedByZeros","decimalAdjacentToLeadingZeros","num","parsedStr","n","node2json_METADATA_SYMBOL","XMLParser","parse","validationOption","toString","validate","tagFound","reachedRoot","tagStartPos","closingTag","readAttributeStr","tagClosed","value","attrStrStart","isValid","otg","openPos","afterAmp","validateAmpersand","validateNumberAmpersand","re","count","JSON","stringify","map","t","Error","orderedObjParser","orderedResult","compress","arr","text","compressedObj","tagObj","property","propName","obj","newJpath","isLeaf","isLeafTag","propCount","assignAttributes","attrMap","jpath","atrrName","addEntity","attr_to_str","attr","attrVal","orderedJs2Xml_replaceEntitiesValue","suppressBooleanAttributes","textValue","json2xml_defaultOptions","format","indentBy","suppressEmptyNode","suppressUnpairedNode","a","oneListGroup","Builder","isAttribute","attrPrefixLen","processTextOrObjNode","indentate","tagEndChar","newLine","object","level","ajPath","j2x","concat","buildTextValNode","buildObjectNode","repeat","prototype","build","jObj","arrayNodeName","jArray","indentation","arrToStr","xmlStr","isPreviousElementTag","orderedJs2Xml_propName","newJPath","tagText","isStopNode","attStr","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","endsWith","includes","join","call","Date","buildAttrPairStr","arrLen","listTagVal","listTagAttr","item","Ks","L","closeTag","tagEndExp","piClosingChar"],"sourceRoot":""}